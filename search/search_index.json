{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"rzk-project-template \u00b6 Template for a formalisation project in rzk proof assistant. How to check \u00b6 From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"General"},{"location":"#rzk-project-template","text":"Template for a formalisation project in rzk proof assistant.","title":"rzk-project-template"},{"location":"#how-to-check","text":"From the root of the project's repository, run: rzk typecheck src/**/*.rzk.md","title":"How to check"},{"location":"0-example.rzk/","text":"Example formalisation module \u00b6 #lang rzk-1 Here is an identity function: #define identity ( A : U) : A \u2192 A := \\ x \u2192 x","title":"Example"},{"location":"0-example.rzk/#example-formalisation-module","text":"#lang rzk-1 Here is an identity function: #define identity ( A : U) : A \u2192 A := \\ x \u2192 x","title":"Example formalisation module"},{"location":"1-types/","text":"2.1 Types are higher groupoids \u00b6 #lang rzk-1 Induction principle for equality types: #def path-ind ( A : U) ( C : ( x : A) -> ( y : A) -> (x = y) -> U) ( d : ( x : A) -> C x x refl ) : ( x : A) -> ( y : A) -> ( p : x = y) -> C x y p := \\ x y p -> idJ ( A , x , C x , d x , y , p ) 2.1.1. Symmetry - Inversion of paths \u00b6 #def path-sym ( A : U) ( x y : A) : (x = y) -> (y = x) := path-ind A ( \\ x y _ -> y = x) ( \\ z -> refl ) x y 2.1.2. Transitivity - Concatenation of paths \u00b6 #def path-concat ( A : U) ( x y : A) : (x = y) -> ( z : A) -> (y = z) -> (x = z) := \\ p -> path-ind A ( \\x y p -> ((z : A) -> (y = z) -> (x = z))) ( \\ x z q -> path-ind A ( \\ x z q -> (x = z)) ( \\ x -> refl ) x z q ) x y p 2.1.4. \u00b6 Coherence laws on operations of inversion and concatenation (i) - composition with refl \u00b6 #def concat-refl ( A : U) ( x y : A) ( p : x = y) : p = path-concat A x y y p refl := path-ind A ( \\ x y p -> p = path-concat A x y y p refl ) ( \\ _ -> refl ) x y p #def refl-concat ( A : U) ( x y : A) ( p : x = y) : p = path-concat A x x y refl p := path-ind A ( \\ x y p -> p = path-concat A x x y refl p) ( \\ _ -> refl ) x y p (ii) - composition with inverse \u00b6 #def inverse-l ( A : U) ( x y : A) ( p : x = y) : path-concat A y x y (path-sym A x y p) p = refl := path-ind A ( \\ x y p -> path-concat A y x y (path-sym A x y p) p = refl ) ( \\ _ -> refl ) x y p #def inverse-r ( A : U) ( x y : A) ( p : x = y) : path-concat A x y x p (path-sym A x y p) = refl := path-ind A ( \\ x y p -> path-concat A x y x p (path-sym A x y p) = refl ) ( \\ _ -> refl ) x y p (iii) - inverse of inverse \u00b6 #def inverse-twice ( A : U) ( x y : A) ( p : x = y) : path-sym A y x (path-sym A x y p) = p := path-ind A ( \\ x y p -> path-sym A y x (path-sym A x y p) = p ) ( \\ _ -> refl ) x y p (iv) - associativity of concatenation \u00b6 #def concat-assoc' ( A : U) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r ) ( \\ x z q w r -> refl ) x y p #def concat-assoc ( A : U) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r ) ( \\x z q -> path-ind A (\\x z q -> (w : A) -> ( r : z = w) -> path-concat A x z w q r = path-concat A x z w q r) ( \\ x w r -> path-ind A ( \\ x w r -> r = r) ( \\ x -> refl ) x w r) x z q) x y p","title":"1 types"},{"location":"1-types/#21-types-are-higher-groupoids","text":"#lang rzk-1 Induction principle for equality types: #def path-ind ( A : U) ( C : ( x : A) -> ( y : A) -> (x = y) -> U) ( d : ( x : A) -> C x x refl ) : ( x : A) -> ( y : A) -> ( p : x = y) -> C x y p := \\ x y p -> idJ ( A , x , C x , d x , y , p )","title":"2.1 Types are higher groupoids"},{"location":"1-types/#211-symmetry-inversion-of-paths","text":"#def path-sym ( A : U) ( x y : A) : (x = y) -> (y = x) := path-ind A ( \\ x y _ -> y = x) ( \\ z -> refl ) x y","title":"2.1.1. Symmetry - Inversion of paths"},{"location":"1-types/#212-transitivity-concatenation-of-paths","text":"#def path-concat ( A : U) ( x y : A) : (x = y) -> ( z : A) -> (y = z) -> (x = z) := \\ p -> path-ind A ( \\x y p -> ((z : A) -> (y = z) -> (x = z))) ( \\ x z q -> path-ind A ( \\ x z q -> (x = z)) ( \\ x -> refl ) x z q ) x y p","title":"2.1.2. Transitivity - Concatenation of paths"},{"location":"1-types/#214","text":"Coherence laws on operations of inversion and concatenation","title":"2.1.4."},{"location":"1-types/#i-composition-with-refl","text":"#def concat-refl ( A : U) ( x y : A) ( p : x = y) : p = path-concat A x y y p refl := path-ind A ( \\ x y p -> p = path-concat A x y y p refl ) ( \\ _ -> refl ) x y p #def refl-concat ( A : U) ( x y : A) ( p : x = y) : p = path-concat A x x y refl p := path-ind A ( \\ x y p -> p = path-concat A x x y refl p) ( \\ _ -> refl ) x y p","title":"(i) - composition with refl"},{"location":"1-types/#ii-composition-with-inverse","text":"#def inverse-l ( A : U) ( x y : A) ( p : x = y) : path-concat A y x y (path-sym A x y p) p = refl := path-ind A ( \\ x y p -> path-concat A y x y (path-sym A x y p) p = refl ) ( \\ _ -> refl ) x y p #def inverse-r ( A : U) ( x y : A) ( p : x = y) : path-concat A x y x p (path-sym A x y p) = refl := path-ind A ( \\ x y p -> path-concat A x y x p (path-sym A x y p) = refl ) ( \\ _ -> refl ) x y p","title":"(ii) - composition with inverse"},{"location":"1-types/#iii-inverse-of-inverse","text":"#def inverse-twice ( A : U) ( x y : A) ( p : x = y) : path-sym A y x (path-sym A x y p) = p := path-ind A ( \\ x y p -> path-sym A y x (path-sym A x y p) = p ) ( \\ _ -> refl ) x y p","title":"(iii) - inverse of inverse"},{"location":"1-types/#iv-associativity-of-concatenation","text":"#def concat-assoc' ( A : U) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r ) ( \\ x z q w r -> refl ) x y p #def concat-assoc ( A : U) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ( w : A) -> ( r : z = w) -> path-concat A x y w p (path-concat A y z w q r) = path-concat A x z w (path-concat A x y z p q) r ) ( \\x z q -> path-ind A (\\x z q -> (w : A) -> ( r : z = w) -> path-concat A x z w q r = path-concat A x z w q r) ( \\ x w r -> path-ind A ( \\ x w r -> r = r) ( \\ x -> refl ) x w r) x z q) x y p","title":"(iv) - associativity of concatenation"},{"location":"2-functions/","text":"2.1 Functions are functors \u00b6 #lang rzk-1 2.2.1. \u00b6 application / action on paths #def ap ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : f x = f y := path-ind A ( \\ x y p -> f x = f y) ( \\ x -> refl ) x y p 2.2.2. \u00b6 ap behaves functorially (i) - ap (p \u00b7 q) = ap (p) \u00b7 ap (q) \u00b6 #def ap-concat ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ap A B f x z (path-concat A x y z p q) = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q) := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ap A B f x z (path-concat A x y z p q) = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q)) ( \\ x z q -> refl ) x y p ``` ##### (i) - `ap (inv (p)) = inv (ap (p))` ```rzk #def ap-inverse ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : ap A B f y x (path-sym A x y p) = path-sym B (f x) (f y) (ap A B f x y p) := path-ind A ( \\ x y p -> ap A B f y x (path-sym A x y p) = path-sym B (f x) (f y) (ap A B f x y p)) ( \\ x -> refl ) x y p ``` ##### (iii) - `ap_g (ap_f (p)) = ap_{f \u25e6 g} (p)` ```rzk #def ap-twice ( A B C : U) ( f : A -> B) ( g : B -> C) ( x y : A) ( p : x = y) : ap B C g (f x) (f y) (ap A B f x y p) = ap A C ( \\ x -> g (f x)) x y p := path-ind A ( \\ x y p -> ap B C g (f x) (f y) (ap A B f x y p) = ap A C ( \\ x -> g(f x)) x y p) ( \\ x -> refl ) x y p ``` ##### (iv) - `ap_id` ```rzk #def ap-id ( A : U) ( x y : A) ( p : x = y) : ap A A ( \\ x -> x) x y p = p := path-ind A ( \\ x y p -> ap A A ( \\ x -> x) x y p = p) ( \\ x -> refl ) x y p","title":"2 functions"},{"location":"2-functions/#21-functions-are-functors","text":"#lang rzk-1","title":"2.1 Functions are functors"},{"location":"2-functions/#221","text":"application / action on paths #def ap ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : f x = f y := path-ind A ( \\ x y p -> f x = f y) ( \\ x -> refl ) x y p","title":"2.2.1."},{"location":"2-functions/#222","text":"ap behaves functorially","title":"2.2.2."},{"location":"2-functions/#i-ap-p-q-ap-p-ap-q","text":"#def ap-concat ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : ( z : A) -> ( q : y = z) -> ap A B f x z (path-concat A x y z p q) = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q) := path-ind A ( \\ x y p -> (z : A) -> ( q : y = z) -> ap A B f x z (path-concat A x y z p q) = path-concat B (f x) (f y) (f z) (ap A B f x y p) (ap A B f y z q)) ( \\ x z q -> refl ) x y p ``` ##### (i) - `ap (inv (p)) = inv (ap (p))` ```rzk #def ap-inverse ( A B : U) ( f : A -> B) ( x y : A) ( p : x = y) : ap A B f y x (path-sym A x y p) = path-sym B (f x) (f y) (ap A B f x y p) := path-ind A ( \\ x y p -> ap A B f y x (path-sym A x y p) = path-sym B (f x) (f y) (ap A B f x y p)) ( \\ x -> refl ) x y p ``` ##### (iii) - `ap_g (ap_f (p)) = ap_{f \u25e6 g} (p)` ```rzk #def ap-twice ( A B C : U) ( f : A -> B) ( g : B -> C) ( x y : A) ( p : x = y) : ap B C g (f x) (f y) (ap A B f x y p) = ap A C ( \\ x -> g (f x)) x y p := path-ind A ( \\ x y p -> ap B C g (f x) (f y) (ap A B f x y p) = ap A C ( \\ x -> g(f x)) x y p) ( \\ x -> refl ) x y p ``` ##### (iv) - `ap_id` ```rzk #def ap-id ( A : U) ( x y : A) ( p : x = y) : ap A A ( \\ x -> x) x y p = p := path-ind A ( \\ x y p -> ap A A ( \\ x -> x) x y p = p) ( \\ x -> refl ) x y p","title":"(i) - ap (p \u00b7 q) = ap (p) \u00b7 ap (q)"}]}